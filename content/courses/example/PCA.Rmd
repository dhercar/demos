---
date: "10/09/2021"
math: false
title: PCA in R
type: book
weight: 100
draft: false
hidden: false
output: md_document
---

<!--more-->

In this tutorial you will learn how to use the ``prcomp`` function to perform a principal component analyses (PCA) and display the results in a fully customizable format. I assume you are familiarized with the theory behind a PCA and have basic R-programming skills. 

We are going to use the [iris](https://archive.ics.uci.edu/ml/datasets/iris) dataset as an example. It includes four numerical variables representing four flower characteristics and one categorical variable that corresponds to the taxonomic classification. 

```{r, include=T, echo=T, warning=F}
data(iris) # Load dataset
sapply(iris, class) #Check the class of variables
```

<br> 

## Preparing the data

A good way to inspect the data is to analyse the correlation between variables. For that I like using the ``PerformanceAnalytics`` package. 

```{r}

PerformanceAnalytics:: chart.Correlation(iris[,-5],
                                         histogram=TRUE, 
                                         pch=10,
                                         method = "pearson")
```

There are strong correlations between some variables, specially between ``Petal.Length`` and ``Petal.Width``. For this example we are going to keep both variables, but you could consider removing one when such strong correlations are detected. 

Next, we can visually explore the distribution of the variables.
```{r}
library(ggplot2)

iris.num <- iris[,-5] #variables to use in the PCA


ggplot(stack(data.frame(scale(iris.num))), aes(x=ind, y=values)) +
  geom_boxplot(width=0.5) +  #draw boxplot
  geom_jitter(width=0.1, alpha=0.5) #draw points 

```

The distribution seem symmetric enough. Otherwise, a proper transformation variables would be needed. 

<br>

## PCA

We can use the ``vegan`` package to perfoorm a PCA using the ``rda()``function.   

```{r, warning=FALSE, include=TRUE}

library(vegan)
pca.out <- rda(iris.num, scale=TRUE)
pca.out$inertia
```

The result of the PCA has been stored with the name of ``pca.out``. One important aspect of a PCA is the % of variance explained by each principal component, which can be consulted in the ``$CA$eig`` section of the PCA output. 

```{r}
kableExtra::kable(round(data.frame(summary(pca.out)[6]), 3))

varExp <- pca.out$CA$eig/sum(pca.out$CA$eig)*100 

```

```{r}
ggplot(data.frame(varExp,
                  PC= substr(names(varExp), 3,5)), 
       aes(x=as.numeric(PC), y=varExp))+
    geom_line(col="grey40", size=0.7)+
  geom_point(colour="coral3", size=3) + 
  theme(aspect.ratio=0.5)+
  xlab("PC")+
  ylab("Proportion explained (%)")

```

we obtained _n_ variables - 1 principal components (PC) that include all of the variability in the data. 
The first PC axis summarizes a big part of the variance (>70%) and adding a second PC allows for including more than 9% of the variance.The appropriate number of PC to represent our data we be can be selected using the _Kaiser-Guttman_ criterion, which selects all PC with eigenvalues higher than 1. Just for fun, I will create a little function that automatically selects the optimum number of PC. 

```{r}


KG_criterion <- function(df, threshold=1, scale=TRUE, raw.data=TRUE){
  pca.out<- rda(df,scale= scale)
  nPC <- sum(ifelse(pca.out$CA$eig>threshold,1,0))
  print(paste("Number of dimensions selected using Kaiser-Guttman criterion = ", nPC))
  }

KG_criterion(df=iris.num)

```

Following this, one PC axis would be enough to represent our data. However, the second PC has an eigenvalue close enough to 0 to still represent the data in 2D, which is preferable. 


<br>

## 3 levels of BIPLOT: from basic to fancy

### Level 1: Basic biplot

The ``autoplot()`` function of the ``ggfortify`` R package is an easy way to obtain PCA biplots that are based on ``ggplot2``.  Note that it needs the output of the built-inn function ``prcomp()`` instead of the ``rda()`` from ``vegan``. 

```{r}
library(ggplot2)
library(ggfortify)

pca.out2<- prcomp(iris.num, scale. = T) 

autoplot(pca.out2,
         loadings= TRUE,
         loadings.label=TRUE)
```

<br>

### Level 2: Adding extra variables

We can add more information
```{r, warning=FALSE}

 autoplot(pca.out2,  # prcomp output
         data=iris,  # original data
         colour= "Species", # different colour for each species
         shape= "Species", # different shape for each species
         loadings= TRUE, # Add arrows to represent the correlation of the variables with each PC
         loadings.label=TRUE, # Add labels to each arrow
         frame=TRUE # indicate the area where the samples of each group are found
         ) 
```

<br>

### Level 3: Customizing the plot

``autoplot()`` returns a ggplot object so we can add ``ggplot2`` functions. For example, we can split the plot using the ``facet_wrap()`` function, define a manual colour scale and tweak some theme settings. 

```{r, warning=FALSE}

autoplot(pca.out2,  # prcomp output
         data=iris,  # original data
         colour= "Species", # different colour for each species
         shape= "Species", # different shape for each species
         loadings= TRUE, # Add arrows to represent the correlation of the variables with each PC
         loadings.label=TRUE, # Add labels to each arrow
         frame=TRUE # indicate the area where the samples of each group are found
         ) + # We can use ggplot2 syntax functions
  theme_bw() + # Change deafault theme 
  facet_wrap(~Species, ncol=3)+ #split the plot
  scale_color_manual(values=c("coral3", "darkolivegreen", "steelblue"))+ #manual colours
  theme(aspect.ratio=1, legend.position= "bottom", panel.grid = element_blank()) # 1:1 plots
```


Adding 2D-density areas is a cool way to visualize differences among groups of variables. 

```{r, warning=FALSE}

autoplot(pca.out2, 
         data=iris,  
         colour= "Species",
         ) + 
  theme_bw() + 
  stat_density_2d(geom="polygon",aes(fill=Species), bins=10, alpha=0.1) + # 2D density polygons
  stat_density_2d(aes(col=Species), bins=10) +  # 2D density lines (make sure to number of bins are equal)
  scale_color_manual(values=c("coral3", "darkolivegreen", "steelblue"))+ 
  theme(aspect.ratio=1, legend.position= "bottom", panel.grid = element_blank()) 
```




